# JVM虚拟机 摘自[王二的Java进阶之路](https://javabetter.cn/jvm/#%E5%B0%8F%E5%86%8C%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9)

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/xuexiluxian/java/jvm-b4ec034b-9f20-40b9-a2a3-e77afffd2abf.png)

## JVM简要介绍

在很久以前，Green项目组想要开发一种跨平台的程序架构，C++是不行的，因为C++在Windows下编译的，无法拿到Linux环境里直接运行。

但是有一个东西叫做直译器，也叫解释器，就是每跑一行代码就生成机器码，然后执行。像Python和Ruby就是直译器。

那么每个操作系统都装一个直译器不就解决了？

但是直译器有个缺点，就是没办法像编译器那样对一些热点代码进行优化，从而加速程序的运行。

那么怎么办？

结果是：编译器和直译器一起上！也就是Java的方式。

![image](https://cdn.tobebetterjavaer.com/stutymore/what-is-jvm-20231019153456.png)

编译器负责把Java源代码编译成字节码，然后JVM负责把字节码转换成机器码。转换的时候，可以做一些压缩或者优化。通过JIT来完成，加速程序速度。

Java编译器跨平台的目的达到了，而且性能也得到了优化！唯一缺点应该是JVM占内存空间比较大。

热点代码探测，指的是，通过执行计数器找到最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译，解释器就会直接把一整个方法的所有字节码翻译成机器码再执行。

这样的话效率提高很多。这个就是JIT技术。

### JVM的组织架构

JVM可以大概分为三个部分：分别是类加载器、运行时数据区以及执行引擎。英文分别是Class Loader、Runtime Data Areas和Execution
Engine。

### 类加载器

类加载器是最重要的，用来加载类文件。如果类文件加载失败，也就不会有运行时数据区和执行引擎。

类加载器负责把字节码文件加载到内存中。主要会经历加载->连接->实例化这三个阶段。

### 运行时数据区

JVM定义了Java程序运行其间需要用到的内存区域，简单来说，这块区域里面存放了字节码信息以及程序执行过程中的数据，垃圾收集器也会针对运行时数据区做对象回收。

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/seven-07.png)

运行时数据其通常包括方法区、堆、本地方法栈、虚拟机栈和程序计数器五部分组成。

### 执行引擎

执行引擎主要用来干具体的事情。虚拟机和物理机都有执行代码的能力。区别在于，物理机的执行引擎是直接建立在操作系统层面，而虚拟机的执行引擎是由软件自行实现的，因此可以更多样化，能支持不被硬件直接支持的指令集格式。

执行引擎的任务就是把字节码指令解释、编译为对应平台上的本地机器指令才可以。充当了把高级语言翻译为机器语言的角色。

![image](https://cdn.tobebetterjavaer.com/stutymore/what-is-jvm-20231223155202.png)

- 解释器：读取字节码，执行指令。但是是一行行地，跟python等语言一样。所以执行速度比较慢。
- 即时编译器：执行引擎先按照解释执行的方式来执行，慢慢地即时编译器会选择性地把一些热点代码编译成本地代码，执行本地代码速度比一条条解释执行速度快，因为本地代码是直接保存在缓存里的。
- 垃圾回收器：用来回收堆内存中的垃圾对象。

## JVM如何运行Java代码？

当有了.class文件之后，JVM会先通过类加载器加载字节码文件，然后把字节码加载到JVM的运行时数据区，再通过执行引擎转化为机器码最终交给操作系统去执行。

如果虚拟机中的当前线程执行的是Java的普通方法，那么PC寄存器存储的是方法的第一条指令。当方法开始执行之后，PC寄存器存储的是下一个字节码指令的地址。

如果虚拟机中当前线程执行的是native方法，那么PC寄存器中的值为undefined。

如果遇到判断分支、循环等控制转移语句，PC寄存器会被置为目标字节码的地址。

除了PC寄存器外，字节码指令的执行流转还需要虚拟机栈参与。虚拟机栈的大致结构如下：

![image](https://cdn.tobebetterjavaer.com/stutymore/how-run-java-code-20231031142106.png)

虚拟机栈操作的基本元素就是栈帧，栈帧主要包含了局部变量表、操作数栈、动态链接以及方法返回地址。栈是先进后出的数据结构。每个方法从调用到执行完成都对应一个栈帧的入栈和出栈。

## Java的类加载机制

class文件开头有魔数“cafe babe”。这就是JVM识别.class的标志。

### 类加载过程

Java的类加载过程：
![image](https://cdn.tobebetterjavaer.com/stutymore/class-load-20231031202641.png)

类从被加载到JVM开始，到卸载出内存，整个生命周期分为7个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。

![image](https://cdn.tobebetterjavaer.com/stutymore/class-load-20231031202641.png)

其中、验证、准备、解析这三个阶段统称为链接。

除去使用和卸载，其他剩下的就是Java的类加载过程。

这5个顺序一般是顺序发生的，但是在动态绑定的情况下，解析阶段发生在初始化阶段之后。

- Loading：加载阶段
  JVM在这个阶段的目的是把字节码从不同的数据源(可能是class文件、可能是jar包、甚至网络)转换为二进制字节流加载到内存中，并生成一个代表该类的Class对象。

- Verification：验证阶段
  JVM会在这个阶段对二进制字节流进行校验，只有符合JVM字节码规范的才能被JVM正确执行。这个阶段是保证JVM安全的重要屏障，下面是一些主要的检查。
    - 确保二进制字节流符合预期，比如是否是cafe babe开头
    - 巴拉巴拉

- Preparation：准备阶段
  JVM会在这个阶段对类变量(注意是类的变量，也就是static的)分配内存并初始化，对应数据类型的默认初始值。

```java
public String chenmo = "沉默";
public static String wanger = "王二";
public static final String cmower = "沉默王二";
```

比如上面的代码，在准备阶段，chenmo不会被分配内存，因为它是对象的变量，而wanger会被分配内存，但是默认值是null而不是“王二”。而cmower会被分配变量，并且它是static
final修饰，也就不是类的变量而是常量了。因此它直接初始化值就等于“沉默王二”


- Resolution：解析阶段
  该阶段将常量池中的符号引用转化为直接引用。 什么是符号引用，什么是直接引用？

符号引用，以一组符号来描述所引用的目标。因为在编译的时候，Java类肯定是不知道所引用的类的实际地址的。因此只能用符号引用来代替。比如com.Wanger类引用了com.Chenmo类。编译时Wanger类并不知道Chenmo类的实际内存地址，因此都是用符号com.Chenmo。

直接引用，通过对符号引用进行解析，找到引用的实际内存地址。

符号引用：

- 定义：包含了类、字段、方法、接口等多种符号的全限定名
- 特点：在编译时生成、存储在编译后的字节码的常量池中
- 独立性：不依赖于具体的内存地址，有更好的灵活性

直接引用：

- 定义：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
- 特点：在运行时生成
- 效率：因为是直接指向内存地址或者偏移量，所以直接引用访问对象的效率较高。

如果不涉及动态加载，那么解析结果可以缓存，避免多次解析同一个符号。这个情况下，解析发生在初始化之前。

但是如果用了动态加载，前面解析过的符号，后面再次解析，结果可能会不同。而动态加载时，解析过程发生在程序执行到这条指令的时候。因此此时，动态加载时，解析会发生在初始化之后。

解析阶段的工作：解析类、接口、类方法、接口方法、字段。

- Initialization：初始化
- 这个阶段是类加载过程的最后一步。这时候，类变量将被赋值为代码里的值。

上面这段话可能说得很抽象，不好理解，我来举个例子。

```java
String cmower = new String("沉默王二");
```

上面这段代码使用了 new 关键字来实例化一个字符串对象，那么这时候， 就会调用 String 类的构造方法对 cmower 进行实例化。

```java
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
```

初始化的时机：
- 创建类的实例时
- 访问类的静态方法或者静态字段时
- 使用 java.lang.reflect 包的方法对类进行反射调用时
- 初始化一个类的子类时
- JVM启动时，初始化主类

### 类加载器

![image](https://cdn.tobebetterjavaer.com/stutymore/what-is-jvm-20231030185834.png)

对任意一个类，都由它的类加载器和类本身一同确定其在JVM中的唯一性。如果两个类的加载器不同，即使来源于同一个字节码文件，两个类也不相等。

类加载器可以分为四个类型：
- Bootstrap ClassLoader：引导类加载器。负责加载JVM核心类库。
- Extension ClassLoader：扩展类加载器。加载Java扩展库的类。
- System ClassLoader：系统类加载器。负责加载系统类路径java.class.path上指定的类库，通常是应用类和第三方库。
- User ClassLoader：用户自定义类加载器。用户可以自己定义类加载器。

### 双亲委派模型

这是Java类加载器使用的一种机制，用于确保Java程序的稳定性和安全性。类加载器在尝试加载一个类时，首先会委派给父加载器去加载，失败了才会自己尝试去加载。

这个委派是递归的，父加载器又会委派它的父加载器，最后从启动类加载器开始、再到扩展类加载器、再到系统类加载器。

这样可以确保不会重复加载类，并保护Java核心API不被恶意替换。

防止重复加载：比如我自定义了一个String类。按照双亲委派模型，会先让引导类加载器尝试加载，然后它的lib/rt.jar中已经有String类了，所以不会重复加载。
保护核心API：类似同上，建立同名但是修改过的类，根据双亲委派模型会加载正版的类，子类加载器不会执行，也就不会导入。

## Java类文件结构

紧跟着魔数后面的四个字节 0000 0037 分别表示副版本号和主版本号。也就是说，主版本号为 55（0x37 的十进制），也就是 Java 11 对应的版本号，副版本号为 0。

## 从javap角度看懂字节码

## 栈虚拟机和寄存器虚拟机

从硬件层面，栈位于内存中、寄存器在CPU中，这就是为什么一般情况下，基于寄存器结构的虚拟机会比基于栈的虚拟机快的原因。

HotSpot VM是基于栈的一种虚拟机，当Java程序运行时，HotSpot VM加载编译后的字节码文件，也就是.class。解释器或JIT读取字节码指令并转换成机器码。

方法调用、执行过程中的数据，会存储在栈中。

基于栈的优点是可移植性更好、指令更短、实现起来简单，但不能随机访问栈中的元素，完成相同功能所需要的指令数也比寄存器的要多，需要频繁的入栈和出栈。

基于寄存器的优点是速度快，有利于程序运行速度的优化，但操作数需要显式指定，指令也比较长。

## 字节码指令详解
直接skip

## 深入理解栈帧结构

每一个栈帧都包括了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息

一个线程中的方法调用链可能很长，很多方法都处于执行状态。当前线程位于栈顶的栈帧被称为当前栈帧。

### 局部变量表
它用来保存方法中的局部变量，以及方法参数。当Java源代码文件被编译成class文件的时候，局部变量表的最大容量就是确定的。

### 操作数栈
它的最大深度也是在编译时就已经确定。

### 动态链接
每个栈帧都包含了一个指向运行时常量池该栈帧所属方法的引用。

![image](https://cdn.tobebetterjavaer.com/stutymore/vm-stack-register-20231222175706.png)

