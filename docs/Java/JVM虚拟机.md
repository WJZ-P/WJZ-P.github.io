# JVM虚拟机 摘自[王二的Java进阶之路](https://javabetter.cn/jvm/#%E5%B0%8F%E5%86%8C%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9)

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/xuexiluxian/java/jvm-b4ec034b-9f20-40b9-a2a3-e77afffd2abf.png)

## JVM简要介绍

在很久以前，Green项目组想要开发一种跨平台的程序架构，C++是不行的，因为C++在Windows下编译的，无法拿到Linux环境里直接运行。

但是有一个东西叫做直译器，也叫解释器，就是每跑一行代码就生成机器码，然后执行。像Python和Ruby就是直译器。

那么每个操作系统都装一个直译器不就解决了？

但是直译器有个缺点，就是没办法像编译器那样对一些热点代码进行优化，从而加速程序的运行。

那么怎么办？

结果是：编译器和直译器一起上！也就是Java的方式。

![image](https://cdn.tobebetterjavaer.com/stutymore/what-is-jvm-20231019153456.png)

编译器负责把Java源代码编译成字节码，然后JVM负责把字节码转换成机器码。转换的时候，可以做一些压缩或者优化。通过JIT来完成，加速程序速度。

Java编译器跨平台的目的达到了，而且性能也得到了优化！唯一缺点应该是JVM占内存空间比较大。

热点代码探测，指的是，通过执行计数器找到最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译，解释器就会直接把一整个方法的所有字节码翻译成机器码再执行。

这样的话效率提高很多。这个就是JIT技术。

### JVM的组织架构

JVM可以大概分为三个部分：分别是类加载器、运行时数据区以及执行引擎。英文分别是Class Loader、Runtime Data Areas和Execution Engine。

### 类加载器

类加载器是最重要的，用来加载类文件。如果类文件加载失败，也就不会有运行时数据区和执行引擎。

类加载器负责把字节码文件加载到内存中。主要会经历加载->连接->实例化这三个阶段。

### 运行时数据区

JVM定义了Java程序运行其间需要用到的内存区域，简单来说，这块区域里面存放了字节码信息以及程序执行过程中的数据，垃圾收集器也会针对运行时数据区做对象回收。

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/seven-07.png)

运行时数据其通常包括方法区、堆、本地方法栈、虚拟机栈和程序计数器五部分组成。

### 执行引擎

执行引擎主要用来干具体的事情。虚拟机和物理机都有执行代码的能力。区别在于，物理机的执行引擎是直接建立在操作系统层面，而虚拟机的执行引擎是由软件自行实现的，因此可以更多样化，能支持不被硬件直接支持的指令集格式。

执行引擎的任务就是把字节码指令解释、编译为对应平台上的本地机器指令才可以。充当了把高级语言翻译为机器语言的角色。

![image](https://cdn.tobebetterjavaer.com/stutymore/what-is-jvm-20231223155202.png)

- 解释器：读取字节码，执行指令。但是是一行行地，跟python等语言一样。所以执行速度比较慢。
- 即时编译器：执行引擎先按照解释执行的方式来执行，慢慢地即时编译器会选择性地把一些热点代码编译成本地代码，执行本地代码速度比一条条解释执行速度快，因为本地代码是直接保存在缓存里的。
- 垃圾回收器：用来回收堆内存中的垃圾对象。

## JVM如何运行Java代码？

当有了.class文件之后，JVM会先通过类加载器加载字节码文件，然后把字节码加载到JVM的运行时数据区，再通过执行引擎转化为机器码最终交给操作系统去执行。

如果虚拟机中的当前线程执行的是Java的普通方法，那么PC寄存器存储的是方法的第一条指令。当方法开始执行之后，PC寄存器存储的是下一个字节码指令的地址。

如果虚拟机中当前线程执行的是native方法，那么PC寄存器中的值为undefined。

如果遇到判断分支、循环等控制转移语句，PC寄存器会被置为目标字节码的地址。

除了PC寄存器外，字节码指令的执行流转还需要虚拟机栈参与。虚拟机栈的大致结构如下：

![image](https://cdn.tobebetterjavaer.com/stutymore/how-run-java-code-20231031142106.png)

虚拟机栈操作的基本元素就是栈帧，栈帧主要包含了局部变量表、操作数栈、动态链接以及方法返回地址。栈是先进后出的数据结构。每个方法从调用到执行完成都对应一个栈帧的入栈和出栈。

## Java的类加载机制

class文件开头有魔数“cafe babe”。这就是JVM识别.class的标志。

### 类加载过程
Java的类加载过程：
![image](https://cdn.tobebetterjavaer.com/stutymore/class-load-20231031202641.png)

类从被加载到JVM开始，到卸载出内存，整个生命周期分为7个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。

![image](https://cdn.tobebetterjavaer.com/stutymore/class-load-20231031202641.png)

其中、验证、准备、解析这三个阶段统称为链接。

除去使用和卸载，其他剩下的就是Java的类加载过程。

这5个顺序一般是顺序发生的，但是在动态绑定的情况下，解析阶段发生在初始化阶段之后。

- Loading：加载阶段
JVM在这个阶段的目的是把字节码从不同的数据源(可能是class文件、可能是jar包、甚至网络)转换为二进制字节流加载到内存中，并生成一个代表该类的Class对象。

- Verification：验证阶段
JVM会在这个阶段对二进制字节流进行校验，只有符合JVM字节码规范的才能被JVM正确执行。这个阶段是保证JVM安全的重要屏障，下面是一些主要的检查。
  - 确保二进制字节流符合预期，比如是否是cafe babe开头
  - 巴拉巴拉

- Preparation：准备阶段
