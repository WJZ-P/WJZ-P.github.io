# Java并发编程 来自[王二的Java进阶之路](https://javabetter.cn/thread/thread-state-and-method.html)

### 创建线程的三种方式

- 继承Thread类
- 实现Runnable接口
- 实现Callable接口

控制线程的其他方法

- sleep()，join()，setDaemon()，yield()

join()，是Thread的方法，这个线程执行完后才会轮到后续线程得到CPU执行权。

setDaemon()线程标记为守护线程，就是服务其他的线程。

当所有非守护线程结束时，守护线程会被JVM强行关闭。场景是辅助性、可随时中断的任务，比如监控、心跳、临时缓存清理。

yield()是一个静态方法，标识当前线程让出控制权，重新和其他线程一起参与线程调度。但是可能调度器会继续让这个线程运行。

### Java线程的6种状态以及切换

```java
// Thread.State 源码
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED
}
```

- New
  尚未启动的线程，也就是还没调用.start()方法。反复调用同一个线程的.start()
  是不可行的，第二次调用就会抛出`IllegalThreadStateException`
- RUNNABLE
  标识当前线程正在运行中。它是在Java虚拟机中运行，也有可能在等待CPU分配资源。它事实上包括了操作系统线程的ready和running两个状态。
- BLOCKED
  阻塞状态，线程在等待锁的释放。
- WAITING
  线程调用了`Object.wait()`：使当前线程处于等待状态直到另一个线程唤醒它；
  `Thread.join()`：等待线程执行完毕，底层调用的是 Object 的 wait 方法；
  `LockSupport.park()`：除非获得调用许可，否则禁用当前线程进行线程调度。LockSupport 我们在后面会细讲。
- TIMED_WAITING
超时等待，到时间会自动唤醒。
调用如下方法会使线程进入超时等待状态：

Thread.sleep(long millis)：使当前线程睡眠指定时间；
Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；
Thread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；
LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；LockSupport 我们在后面会细讲；
LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；

- TERMINATED
终止状态，线程执行完毕。

### 线程组和线程优先级

ThreadGroup是一个标准的向下引用的树状结构，这个设计防止上级线程被下级线程引用而无法有效GC回收。

Thread和ThreadGroup有setMaxPriority方法，设置优先级，优先级高的线程有更大的概率得到执行。

但是最高的优先级是按线程所在的线程组的。线程组优先级是5，内部线程即使手动设置为10，实际上也是5的优先级。

### 进程和线程

进程是应用程序在内存中分配的空间，也就是正在运行的程序。

CPU用时间片轮转的方式运行进程，给每个进程分配时间段，叫时间片。时间片结束了进程还在运行，就暂停，分配给另一个进程，这个过程叫上下文切换。进程在时间片结束之前结束了，CPU会直接进行切换。

但是进程内部实际上也会有子任务，如果没有线程，进程的任务必须一个个执行，这不是我们想要的，于是有了线程。

#### 进程和线程的区别

进程是独立的运行环境，线程是进程中的一个任务，**本质区别是是否占有独立内存空间和其他系统资源。**

进程有单独内存空间，一个进程出问题不会影响另一个。进程的创建和销毁要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息。

**进程是操作系统资源分配的基本单位，线程是操作系统进行调度的基本单位。**

### 线程安全性问题

```java
int test() {
  int i = 0; // 操作1
  i++;   // 操作2
  int j = i; // 操作3
  i = i + 1; // 操作4
}
```

上面的操作2和4都不是原子的，包括了读取i的值，+1，写回i三步。

每个线程都有属于自己的工作内存，工作内存和主内存之间要通过store和load等进行交互。

为了解决这个可见性问题，Java有volatile关键字，一个变量被volatile修饰时，保证修改的值会马上更新到主存，确保其他线程可见。

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/thread-bring-some-problem-119223c9-83a9-42e1-9a0c-f9c706a1e793.png)

### Java的内存模型JMM

Java Memory Model

并发编程存在两个问题：
- 线程间如何通信？
- 线程间如何同步？

两种并发模型可以解决这个问题。
- 消息传递并发模型
- 内存共享并发模型

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/jmm-a610752d-ef73-47f2-b02c-6954eb3d62bf.png)

**Java使用的是共享内存并发模型**

Java运行时数据区：方法区、堆、虚拟机栈、本地方法栈、程序计数器

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/jmm-0b9e4b1e-90e2-41bb-be89-f65e3a10fa08.png)

#### 内存可见性问题是如何发生的？

现代计算机为了高效，会在高速缓存区存储共享变量，因为CPU访问缓存比内存快得多。

所有的共享变量都存在主存中。每个线程保存了一份该线程使用的共享变量的副本。

线程AB之间要通信，必须经过两步：A把本地变量刷新到主存中。B从贮存读取A之前更新的共享变量。

JMM规定，线程对共享变量的所有操作必须在自己的本地内存中进行，不能直接从主存中读取。

**为什么要有工作(本地)内存？** 这样设计是为了性能考虑。本地内存包含缓存，CPU访问缓存很快。

JMM通过控制主存与每个线程的本地内存之间的交互提供内存可见性保证。

### JMM与Java运行时内存区域的区别

两者是不同的概念，JMM是抽象的，是一组规则，围绕原子性、有序性、可见性等展开，Java运行时内存是具体的，是JMM运行Java程序时必要的内存划分

**两者都存在私有数据区域和共享数据区域**。JMM的主存属于共享数据区域，包含堆和方法区。JMM的本地内存属于私有数据区域，包含程序计数器、本地方法栈、虚拟机栈。

Java运行时内存区域描述在JVM运行时，怎么把内存划分为不同的区域。

- 方法区：存储了每一个类的结构信息，如运行时常量池，字段和方法数据构造方法和普通方法的字节码内容。
- 堆：几乎所有的对象实例和数组都在这里分配内存。这是Java内存管理的主要区域。
- 栈：每个线程有一个私有的栈，每次方法调用会创建新的栈帧，用来存储局部变量、操作数栈等信息。
- 本地方法栈：跟栈差不多，但是是为JVM用到的native方法服务。
- 程序计数器：每个线程独立，指示当前线程执行到了字节码的哪一行。

### volatile关键字

它会禁止指令重排。如何实现的？Java内存模型会为volatile变量插入内存屏障(一个处理器指令)，实现写屏障和读屏障。

- 写屏障(Write Barrier):当一个volatile变量被写入时，写屏障保证该屏障之前所有变量的写入都提交到主内存。
- 读屏障(Read Barrier):当读取一个volatile变量时，读屏障确保屏障之后的所有读操作都从主存中读取。



