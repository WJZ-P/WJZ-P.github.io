___# Java并发编程 来自[王二的Java进阶之路](https://javabetter.cn/thread/thread-state-and-method.html)

### 创建线程的三种方式

- 继承Thread类
- 实现Runnable接口
- 实现Callable接口

控制线程的其他方法

- sleep()，join()，setDaemon()，yield()

join()，是Thread的方法，这个线程执行完后才会轮到后续线程得到CPU执行权。

setDaemon()线程标记为守护线程，就是服务其他的线程。

当所有非守护线程结束时，守护线程会被JVM强行关闭。场景是辅助性、可随时中断的任务，比如监控、心跳、临时缓存清理。

yield()是一个静态方法，标识当前线程让出控制权，重新和其他线程一起参与线程调度。但是可能调度器会继续让这个线程运行。

### Java线程的6种状态以及切换

```java
// Thread.State 源码
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED
}
```

- New
  尚未启动的线程，也就是还没调用.start()方法。反复调用同一个线程的.start()
  是不可行的，第二次调用就会抛出`IllegalThreadStateException`
- RUNNABLE
  标识当前线程正在运行中。它是在Java虚拟机中运行，也有可能在等待CPU分配资源。它事实上包括了操作系统线程的ready和running两个状态。
- BLOCKED
  阻塞状态，线程在等待锁的释放。
- WAITING
  线程调用了`Object.wait()`：使当前线程处于等待状态直到另一个线程唤醒它；
  `Thread.join()`：等待线程执行完毕，底层调用的是 Object 的 wait 方法；
  `LockSupport.park()`：除非获得调用许可，否则禁用当前线程进行线程调度。LockSupport 我们在后面会细讲。
- TIMED_WAITING
超时等待，到时间会自动唤醒。
调用如下方法会使线程进入超时等待状态：

Thread.sleep(long millis)：使当前线程睡眠指定时间；
Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；
Thread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；
LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；LockSupport 我们在后面会细讲；
LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；

- TERMINATED
终止状态，线程执行完毕。

### 线程组和线程优先级

ThreadGroup是一个标准的向下引用的树状结构，这个设计防止上级线程被下级线程引用而无法有效GC回收。

Thread和ThreadGroup有setMaxPriority方法，设置优先级，优先级高的线程有更大的概率得到执行。

但是最高的优先级是按线程所在的线程组的。线程组优先级是5，内部线程即使手动设置为10，实际上也是5的优先级。

### 进程和线程

进程是应用程序在内存中分配的空间，也就是正在运行的程序。

CPU用时间片轮转的方式运行进程，给每个进程分配时间段，叫时间片。时间片结束了进程还在运行，就暂停，分配给另一个进程，这个过程叫上下文切换。进程在时间片结束之前结束了，CPU会直接进行切换。

但是进程内部实际上也会有子任务，如果没有线程，进程的任务必须一个个执行，这不是我们想要的，于是有了线程。

#### 进程和线程的区别

进程是独立的运行环境，线程是进程中的一个任务，**本质区别是是否占有独立内存空间和其他系统资源。**

进程有单独内存空间，一个进程出问题不会影响另一个。进程的创建和销毁要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息。

**进程是操作系统资源分配的基本单位，线程是操作系统进行调度的基本单位。**

### 线程安全性问题

```java
int test() {
  int i = 0; // 操作1
  i++;   // 操作2
  int j = i; // 操作3
  i = i + 1; // 操作4
}
```

上面的操作2和4都不是原子的，包括了读取i的值，+1，写回i三步。

每个线程都有属于自己的工作内存，工作内存和主内存之间要通过store和load等进行交互。

为了解决这个可见性问题，Java有volatile关键字，一个变量被volatile修饰时，保证修改的值会马上更新到主存，确保其他线程可见。

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/thread-bring-some-problem-119223c9-83a9-42e1-9a0c-f9c706a1e793.png)

### Java的内存模型JMM

Java Memory Model

并发编程存在两个问题：
- 线程间如何通信？
- 线程间如何同步？

两种并发模型可以解决这个问题。
- 消息传递并发模型
- 内存共享并发模型

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/jmm-a610752d-ef73-47f2-b02c-6954eb3d62bf.png)

**Java使用的是共享内存并发模型**

Java运行时数据区：方法区、堆、虚拟机栈、本地方法栈、程序计数器

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/jmm-0b9e4b1e-90e2-41bb-be89-f65e3a10fa08.png)

#### 内存可见性问题是如何发生的？

现代计算机为了高效，会在高速缓存区存储共享变量，因为CPU访问缓存比内存快得多。

所有的共享变量都存在主存中。每个线程保存了一份该线程使用的共享变量的副本。

线程AB之间要通信，必须经过两步：A把本地变量刷新到主存中。B从贮存读取A之前更新的共享变量。

JMM规定，线程对共享变量的所有操作必须在自己的本地内存中进行，不能直接从主存中读取。

**为什么要有工作(本地)内存？** 这样设计是为了性能考虑。本地内存包含缓存，CPU访问缓存很快。

JMM通过控制主存与每个线程的本地内存之间的交互提供内存可见性保证。

### JMM与Java运行时内存区域的区别

两者是不同的概念，JMM是抽象的，是一组规则，围绕原子性、有序性、可见性等展开，Java运行时内存是具体的，是JMM运行Java程序时必要的内存划分

**两者都存在私有数据区域和共享数据区域**。JMM的主存属于共享数据区域，包含堆和方法区。JMM的本地内存属于私有数据区域，包含程序计数器、本地方法栈、虚拟机栈。

Java运行时内存区域描述在JVM运行时，怎么把内存划分为不同的区域。

- 方法区：存储了每一个类的结构信息，如运行时常量池，字段和方法数据构造方法和普通方法的字节码内容。
- 堆：几乎所有的对象实例和数组都在这里分配内存。这是Java内存管理的主要区域。
- 栈：每个线程有一个私有的栈，每次方法调用会创建新的栈帧，用来存储局部变量、操作数栈等信息。
- 本地方法栈：跟栈差不多，但是是为JVM用到的native方法服务。
- 程序计数器：每个线程独立，指示当前线程执行到了字节码的哪一行。

### volatile关键字

它会禁止指令重排。如何实现的？Java内存模型会为volatile变量插入内存屏障(一个处理器指令)，实现写屏障和读屏障。

- 写屏障(Write Barrier):当一个volatile变量被写入时，写屏障保证该屏障之前所有变量的写入都提交到主内存。
- 读屏障(Read Barrier):当读取一个volatile变量时，读屏障确保屏障之后的所有读操作都从主存中读取。

### synchronized关键字

注意，如果synchronized方法在函数上，实例化两个对象，它们的的对象锁是不一样的。无法保证线程安全。解决方法是把synchronized作用于静态方法，这样锁的就是当前的类，多少个对象都没事。

类上的锁(也就是static的方法)和对象锁(非static方法)不会冲突。

synchronized是可重入锁。在同步块内部再调用有相同锁对象的方法是可以的。

### synchronized到底锁的什么？偏向锁、轻量级锁、重量级锁到底是什么？

介绍一下临界区。临界区，指的是某块代码区域，同一时刻只能由一个线程执行。

#### 锁的四种状态以及锁降级

在 JDK 1.6之前，所有的锁都是“重量级”锁，因为是直接用的操作系统的互斥锁，当一个线程持有锁时，其他试图进入同步块的线程都会被阻塞直到锁释放。涉及到了线程上下文切换以及用户态和内核态切换，效率很低。

这也就是为什么很多开发者会认为synchronized性能很差的原因。

为了减少获得锁和释放锁的性能消耗，JDK1.6引入了“偏向锁”和“轻量级锁”。

JDK1.6之后，一个对象实际上有四种锁状态，由低到高分别是：
1. 无锁
2. 偏向锁
3. 轻量级锁
4. 重量级锁

锁会随着竞争情况逐渐升级，锁升级很容易发生，但是锁降级发生条件比较苛刻。锁降级发生在Stop The World。

#### 对象的锁放在什么地方？
Java的锁是基于对象的。
首先来看看一个对象的锁是存放在什么地方的？

每个Java对象都有一个对象头。如果是非数组类型，用两个字宽存储对象头，如果是数组，会用三个字宽存储对象头。在32位处理器中，一个字宽是32位；64位同理。

Java中，监视器monitor是一种同步工具，用于保护共享数据，避免多线程并发访问导致数据不一致。在Java中，每个对象都有一个内置的监听器。

监视器包括两个重要部分，一个是锁，一个是等待/通知机制。后者是通过object类的wait(),notify()等方法实现的。

#### 偏向锁

偏向锁会偏向于第一个访问锁的线程。如果接下来运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程永远不需要触发同步。偏向锁在无竞争下消除了同步语句，连CAS都没有。

偏向锁在第一次进入同步块时，会在对象头和栈帧中的锁记录里面存储偏向锁线程ID。下次线程进入同步块的时候会查看线程ID是不是自己的。

如果是，说明当前线程获得了锁。如果不是，说明有其他线程在竞争锁。这个时候会尝试CAS来替换MarkWord里面的线程ID为新线程ID。

这个时候会尝试用CAS替换Mark Word里面的线程ID为新线程ID：

- 成功替换，说明之前的线程不存在了，Mark Word里面的线程ID是新线程ID，锁不会升级。
- 失败，说明之前的线程依然存在，暂停它，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，按照轻量级锁的方式进行竞争锁。

#### 撤销偏向锁

偏向锁升级为轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，但是开销很大。
1. 在安全点(这个时间点上没有字节码执行)停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录，要修复锁记录和Mark Word，使其变成无锁状态。
3. 唤醒被停止的线程，将当前锁升级为轻量级锁。

所以如果锁通常处于竞争状态，偏向锁会成为一种累赘。

#### 轻量级锁
JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，叫Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word 里。

然后线程尝试CAS把锁的Mark Word替换为指向锁记录的指针，成功当前线程获得锁，失败表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁。当前线程就尝试使用自旋来获取锁。

自选要消耗CPU，一直获取不到就一直自旋了。

JDK是适应性自旋，如果这次自旋成功，下次自旋次数变多，否则减少。

自旋不是永远的，自旋到一定程度还没获取到锁，自旋失败，线程阻塞，同时锁升级为重量级锁。

#### 轻量级锁的释放
![image](https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728114101.png)

释放锁时，当前线程会用CAS把Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么复制操作会成功。

如果没有竞争，那么会复制成功，如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时释放锁并唤醒被阻塞的线程

![image](https://cdn.tobebetterjavaer.com/stutymore/synchronized-20230728114101.png)___

#### 重量级锁

重量级锁依赖于操作系统的互斥锁。线程间状态切换耗时长，所以重量级锁效率低，但是被阻塞的线程不会消耗CPU。


当多个线程同时请求某个对象锁时，对象锁会设置几种状态区分请求的线程。
- Contention List：所有请求所的线程被放在这个竞争队列。
- Entry List：Contention List中有资格称为候选人的线程被移动到Entry List。
- Wait Set：调用wait方法被阻塞的线程被放置到Wait Set
- OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck
- Owner：获得锁的线程称为Owner
- !Owner：释放锁的线程

上面的状态藏在每个对象的Monitor对象里，只有重量级锁时才会创建。

当一个线程尝试获得锁时，如果已经被占用，则会把这个线程封装成一个ObjectWaiter对象插入到Contention队首，用park方法挂起。

当线程释放锁时，会从Contention List或EntryList挑选一个线程唤醒，被选中的线程叫Heir presumptive，即为假定继承人，假定继承人被唤醒后会尝试获得锁，但是synchronized是非公平的，所以假定继承人不一定能获得锁。

这是因为对于重量级锁，线程尝试获取锁失败，会直接阻塞，等待操作系统调度。

如果线程获得锁之后调用Object.wait，线程会加入WaitSet中，被Object.notify唤醒后，线程会从WaitSet移动到Contention List或者 EntryList中去。需要注意的是，当调用锁对象的wait和notify方法时，如果当前锁的状态是偏向锁或轻量级锁就会先膨胀成重量级锁。

#### 锁的升级流程

每个线程在准备获取共享资源时，先检查MarkWord里面是不是放的自己的ThreadId。如果是，说明当前处于偏向锁状态。

第二步，如果不是，这时候用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前的线程暂停，之前线程把Mark Word内容置空。

第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着用CAS操作，把锁对象的Mark Word内容修改为自己线程内部新建的栈帧地址。

第四步，如果修改成功了，那么CAS成功，该线程获得锁。失败了就进入自旋。

第五步，自旋线程在自选过程中，成功获得资源，仍处于轻量级锁。如果失败。进入重量级锁。自旋进程阻塞，等待之前线程执行完成并唤醒自己.

### 深入浅出偏向锁

首先是monitor。在编译后，monitorenter指令会被插入到同步代码块的开始位置。monitorexit指令会插入到方法结束和异常的位置。

每个对象都有一个monitor关联，当一个线程执行到monitorenter时，就会获得对象所对应monitor的所有权，也就获得到了对象的锁。

#### monitor
Java的monitor相当于守门人，确保同一时刻只有一个线程可以访问受保护的代码段。

工作方式
- 进入房间：当线程进入受保护的代码区域时，它必须得到monitor的允许。
- 等待其他线程：如果房间里已有线程，其他线程必须等待。monitor负责让其他线程等候。
- 离开房间：当线程完成它的工作并离开，monitor会重新打开房门，让等待队列中的下一个线程进入。
- 协调线程：monitor还可以通过例如wait和notify、协调线程之间的合作。线程可以通过monitor发信号给其他线程。

#### Java对象头

Java对象头最多由三部分构成
- Mark Word
- ClassMetadata Address
- Array Length

#### 偏向撤销
偏向锁的撤销和释放是两种机制。释放就是普通的退出同步块。
撤销就是告诉程序这个锁对象不能再使用偏向模式。实践上就是把MarkWord的第三位(是否偏向撤销)值从1变回0.

偏向撤销只发横在有竞争情况下。偏向锁是特定场景下提高效率的方案，但很多地方不满足。容易导致大量的偏向撤销。

大量偏向撤销成本不可以忽视，因此设计有阶梯的底线。

#### 批量重偏向
为每个class维护偏向锁撤销计数器，只要class对象发生偏向撤销，计数器+1，当这个值达到重偏向阈值，默认20时，JVM认为class偏向锁有问题，会进行批量重偏向。

#### 批量撤销
达到重偏向阈值后，达到批量撤销的阈值，默认40时，JVM认为class场景存在多线程竞争，标记class为不可偏向，之后直接走轻量级锁。

#### 偏向锁与HashCode

我们要知道，HashCode不是创建对象就帮我们写到对象头中的，而是要经过第一次调用Object::hashCode() 或者System::identityHashCode(Object)后才会。
偏向锁会来回更改锁对象的Mark Word，对HashCode的生成有影响，怎么办？

实际结论是：即使初始化为可偏向状态的对象，一旦调用了hashCode，进入同步块会直接使用轻量级锁。

另一种场景：已偏向某个线程，后退出同步块，生成了hashcode，然后同一个线程又进入同步块，会发生什么？结论同场景一，直接用轻量级锁。

假如对象已偏向，`在同步块中`生成hashCode，会直接升级成重量级锁。

wait方法是互斥量独有的，调用wait，会直接升级成重量级锁。

#### 再见了，偏向锁。

JDK 15移除辣！！！

## CAS原理

CAS，也就是Compare and Swap，是乐观锁实现方式，无锁的原子操作。

synchronized是悲观锁。