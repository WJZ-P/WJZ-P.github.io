# Java并发编程 来自[王二的Java进阶之路](https://javabetter.cn/thread/thread-state-and-method.html)

### 创建线程的三种方式

- 继承Thread类
- 实现Runnable接口
- 实现Callable接口

控制线程的其他方法

- sleep()，join()，setDaemon()，yield()

join()，是Thread的方法，这个线程执行完后才会轮到后续线程得到CPU执行权。

setDaemon()线程标记为守护线程，就是服务其他的线程。

当所有非守护线程结束时，守护线程会被JVM强行关闭。场景是辅助性、可随时中断的任务，比如监控、心跳、临时缓存清理。

yield()是一个静态方法，标识当前线程让出控制权，重新和其他线程一起参与线程调度。但是可能调度器会继续让这个线程运行。

### Java线程的6种状态以及切换

```java
// Thread.State 源码
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED
}
```

- New
  尚未启动的线程，也就是还没调用.start()方法。反复调用同一个线程的.start()
  是不可行的，第二次调用就会抛出`IllegalThreadStateException`
- RUNNABLE
  标识当前线程正在运行中。它是在Java虚拟机中运行，也有可能在等待CPU分配资源。它事实上包括了操作系统线程的ready和running两个状态。
- BLOCKED
  阻塞状态，线程在等待锁的释放。
- WAITING
  线程调用了`Object.wait()`：使当前线程处于等待状态直到另一个线程唤醒它；
  `Thread.join()`：等待线程执行完毕，底层调用的是 Object 的 wait 方法；
  `LockSupport.park()`：除非获得调用许可，否则禁用当前线程进行线程调度。LockSupport 我们在后面会细讲。
- TIMED_WAITING
超时等待，到时间会自动唤醒。
调用如下方法会使线程进入超时等待状态：

Thread.sleep(long millis)：使当前线程睡眠指定时间；
Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；
Thread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；
LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；LockSupport 我们在后面会细讲；
LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；

- TERMINATED
终止状态，线程执行完毕。

### 线程组和线程优先级

ThreadGroup是一个标准的向下引用的树状结构，这个设计防止上级线程被下级线程引用而无法有效GC回收。

Thread和ThreadGroup有setMaxPriority方法，设置优先级，优先级高的线程有更大的概率得到执行。

但是最高的优先级是按线程所在的线程组的。线程组优先级是5，内部线程即使手动设置为10，实际上也是5的优先级。

### 进程和线程

进程是应用程序在内存中分配的空间，也就是正在运行的程序。

CPU用时间片轮转的方式运行进程，给每个进程分配时间段，叫时间片。时间片结束了进程还在运行，就暂停，分配给另一个进程，这个过程叫上下文切换。进程在时间片结束之前结束了，CPU会直接进行切换。

但是进程内部实际上也会有子任务，如果没有线程，进程的任务必须一个个执行，这不是我们想要的，于是有了线程。

#### 进程和线程的区别

进程是独立的运行环境，线程是进程中的一个任务，**本质区别是是否占有独立内存空间和其他系统资源。**

进程有单独内存空间，一个进程出问题不会影响另一个。进程的创建和销毁要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息。

**进程是操作系统资源分配的基本单位，线程是操作系统进行调度的基本单位。**

### 线程安全性问题

```java
int test() {
  int i = 0; // 操作1
  i++;   // 操作2
  int j = i; // 操作3
  i = i + 1; // 操作4
}
```

上面的操作2和4都不是原子的，包括了读取i的值，+1，写回i三步。

每个线程都有属于自己的工作内存，工作内存和主内存之间要通过store和load等进行交互。

为了解决这个可见性问题，Java有volatile关键字，一个变量被volatile修饰时，保证修改的值会马上更新到主存，确保其他线程可见。

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/thread-bring-some-problem-119223c9-83a9-42e1-9a0c-f9c706a1e793.png)

### Java的内存模型JMM

Java Memory Model

并发编程存在两个问题：
- 线程间如何通信？
- 线程间如何同步？

两种并发模型可以解决这个问题。
- 消息传递并发模型
- 内存共享并发模型

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/jmm-a610752d-ef73-47f2-b02c-6954eb3d62bf.png)

**Java使用的是共享内存并发模型**

Java运行时数据区：方法区、堆、虚拟机栈、本地方法栈、程序计数器

![image](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/jmm-0b9e4b1e-90e2-41bb-be89-f65e3a10fa08.png)

