# MySQL有哪些锁？

![image](https://cdn.xiaolincoding.com//mysql/other/1e37f6994ef44714aba03b8046b1ace2.png)

MySQL的锁主要有全局锁、表级锁、和行锁。

全局锁上了，整个数据库就只支持读操作。
表锁会限制本线程以及其他线程的读写操作。

但是注意在InnoDB引擎下，我们可以用粒度更细的行级锁。

### 元数据锁(MDL)

这个不需要显示使用，因为我们对数据库表进行操作时，会自动给表加上MDL。

对表进行CRUD，加的是MDL读锁，对表做结构变更，加的是MDL写锁。

如果有长事务在执行，同时有线程修改了表的字段，那么这个时候就会被阻塞，此后如果有大量的select请求到来，由于长事务没有释放，表就卡死了。

为什么线程C因为申请不到MDL写锁，而导致后续的读锁也会冲突？因为在等待队列中，写锁的优先级比读锁高。

### 意向锁

- 在使用InnoDB对某些记录加上`共享锁`之前，要在表级别上加一个意向共享锁。

- 在使用InnoDB对某些记录加上`独占锁`之前，要在表级别上加一个意向独占锁。

当执行插入、更新、删除操作的时候对表加上意向独占锁，然后加独占锁。

普通的select不会加行级锁，是通过MVCC实现的一致读。

意向锁的用处是为了快速判断表里面是否有记录被枷锁。

当尝试给表加锁的时候，就会检测这个表是否有意向锁。如果有，说明表里面的某些数据是已经被上锁了，就阻塞。

### AUTO-INC锁

这个锁是特殊的机制，用于自增字段，在执行完插入语句后立即释放。插入数据的时候，会加一个表级别的AUTO-INC锁。

但是这样会有问题，高并发插入数据的时候，会影响插入性能。

因此从MySQL 5.1.22开始。InnoDB存储引擎提供了一种轻量级的锁来实现自增。

一样在插入数据的时候加锁，但是在给自增的字段赋值完毕之后就释放掉，而不是等整个语句执行完成。

但是这样当搭配binlog的日志格式是statement一起使用的时候，在主从复制的时候会发生数据不一致的问题。

具体为什么比较复杂，复习的时候直接看原文。

### 行级锁

查询会枷锁的语句称为锁定读。

- 行级锁主要有三类：`Record Lock` 记录锁，仅仅锁上一条记录。
- `Gap Lock`间隙锁，锁定范围，但是不包括记录本身。
- `Next-Key Lock` 记录锁+间隙锁的组合，锁定范围与记录本身。

### MySQL是怎么加锁的？

#### 在不同隔离级别下，行级锁的种类是不同的。

在读已提交隔离级别上，只会加记录锁。

而在可重复读隔离级别下，除了加记录锁，还会加间隙锁，因为要防止在事务执行过程中发生幻读现象。

而临键锁的规则如下：假如一个事务持有范围是(1,10]的next-key lock，那么另一个事务如果同样获取这个，就会被阻塞。

### MySQL是怎么加行级锁的？

加锁的对象是索引，加锁的基本单位是next-key lock，是由记录锁和间隙锁组合而成的，临键锁是左开右闭区间，间隙锁两侧都是开区间。

但是临键锁在一些场景下会退化成记录锁或间隙锁。

下面所说的都是基于可重复读隔离场景下的。

在用唯一索引进行等值查询的时候，如果记录存在，那么临键锁退化成记录锁(可能是默认加锁都是临键锁？)

如果查询索引不存在，数据库会找第一条大于查询记录的索引的记录，并把这个记录索引的临键锁退化成间隙锁。

加锁的对象是针对索引。

#### 为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 next-key lock会退化成记录锁?

原因就是在唯一索引等值查询并且査询记录存在的场景下，仅靠记录锁也能避免幻读的问题
幻读的定义就是，当一个事务前后两次查询的结果集，不相同时，就认为发生幻读。所以，要
避免幻读就是避免结果集某一条记录被其他事务删除，
或者有其他事务插入了一条新记录，这
样前后两次查询的结果集就不会出现不相同的情况。
由于主键具有唯一性，所以其他事务插入id =1的时候，
会因为主键冲突，导致无法插入id
=1的新记录。这样事务 A在多次査询 id=1的记录的时候，不会出现前后两次查询的结果
集不同，也就避免了幻读的问题。
由于对 id =1加了记录锁，其他事务无法删除该记录，这样事务 A在多次査询 id =1的记
录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。

我观察到一个问题，假设MySQL执行下列语句：

```mysql
select * from user where id < 6 for update;
```

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E6.drawio.png)

这里可以发现，最后一个间隙锁锁住的区间是(5,10)。因为前一个元素是5，后一个是10.这样会导致锁住无关数据！我认为这是一个mysql的设计缺陷，但是一般情况下，唯一索引之间可能值的差别不是很大，所以没优化吧。


### update没加索引会锁全表？

### MySQL记录锁+间隙锁可以防止删除操作导致的幻读吗？

### MySQL死锁了，怎么办？

