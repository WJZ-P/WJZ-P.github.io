# MySQL有哪些锁？

![image](https://cdn.xiaolincoding.com//mysql/other/1e37f6994ef44714aba03b8046b1ace2.png)

MySQL的锁主要有全局锁、表级锁、和行锁。

全局锁上了，整个数据库就只支持读操作。
表锁会限制本线程以及其他线程的读写操作。

但是注意在InnoDB引擎下，我们可以用粒度更细的行级锁。

### 元数据锁(MDL)

这个不需要显示使用，因为我们对数据库表进行操作时，会自动给表加上MDL。

对表进行CRUD，加的是MDL读锁，对表做结构变更，加的是MDL写锁。

如果有长事务在执行，同时有线程修改了表的字段，那么这个时候就会被阻塞，此后如果有大量的select请求到来，由于长事务没有释放，表就卡死了。

为什么线程C因为申请不到MDL写锁，而导致后续的读锁也会冲突？因为在等待队列中，写锁的优先级比读锁高。

### 意向锁

- 在使用InnoDB对某些记录加上`共享锁`之前，要在表级别上加一个意向共享锁。

- 在使用InnoDB对某些记录加上`独占锁`之前，要在表级别上加一个意向独占锁。

当执行插入、更新、删除操作的时候对表加上意向独占锁，然后加独占锁。

普通的select不会加行级锁，是通过MVCC实现的一致读。

意向锁的用处是为了快速判断表里面是否有记录被枷锁。

当尝试给表加锁的时候，就会检测这个表是否有意向锁。如果有，说明表里面的某些数据是已经被上锁了，就阻塞。

### AUTO-INC锁

这个锁是特殊的机制，用于自增字段，在执行完插入语句后立即释放。插入数据的时候，会加一个表级别的AUTO-INC锁。

但是这样会有问题，高并发插入数据的时候，会影响插入性能。

因此从MySQL 5.1.22开始。InnoDB存储引擎提供了一种轻量级的锁来实现自增。

一样在插入数据的时候加锁，但是在给自增的字段赋值完毕之后就释放掉，而不是等整个语句执行完成。

但是这样当搭配binlog的日志格式是statement一起使用的时候，在主从复制的时候会发生数据不一致的问题。

具体为什么比较复杂，复习的时候直接看原文。

### 行级锁

查询会枷锁的语句称为锁定读。

- 行级锁主要有三类：`Record Lock` 记录锁，仅仅锁上一条记录。
- `Gap Lock`间隙锁，锁定范围，但是不包括记录本身。
- `Next-Key Lock` 记录锁+间隙锁的组合，锁定范围与记录本身。

### MySQL是怎么加锁的？


