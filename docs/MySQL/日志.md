# MySQL日志篇

一共有三种日志
- undo log:回滚日志，是InnoDB存储引擎层生成的日志，实现了事务的原子性，主要用于事务回滚和MVCC。
- redo log:重做日志，也是InnoDB层，实现事务的持久性，主要用于断电等故障恢复。
- binlog:归档日志，是server层的日志，主要用于数据备份和主从复制。

这三种日志是如何工作的？

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E6%8F%90%E7%BA%B2.png)

## 为什么需要undo log？

我们做增删改的时候，即使不输入begin和commit来进行事务，MySQL也会隐式开启事务来执行增删改。

那么考虑一个问题，一个事务在执行过程中，在还没有提交事务之前，MySQL崩溃了咋办？怎么回滚到事务之前的数据呢？

如果我们在每次事务执行过程中都记录下回滚时需要的信息到一个日志里，这样中途崩溃就可以通过日志回滚。

实现这个机制的就是undo log，它保证了事务的ACID特性中的原子性Atomicity

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

- 插入一条记录时，记录主键值，回滚时只需要把主键值对应的记录删掉就行了。
- 删除一条记录时，把记录中的内容都记下来，之后回滚时再把这些内容重新插入到表中。
- 更细一条记录时，记录下旧的值，回滚时写回旧的值。

针对delete和update操作有特殊处理：
- delete操作实际上不会立即删除，而是把delete对象打上delete的flag，删除操作是purge线程完成的.
- update分成两种情况，updated列是否是主键
- - 如果不是主键，在undo log 中直接反向记录如何update，update是直接进行的。
- - 如果是主键，update分成两部分执行，先删除该行，再插入一行目标行。

一条记录的每一次更新产生的undo log都有一个roll_pointer指针和一个trx_id事务id：
- 通过trx_id可以知道这个记录是被哪个事务修改的。
- 通过roll_pointer指针把undo log 串成链表，这个链表称为版本链。

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E7%89%88%E6%9C%AC%E9%93%BE.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

- 在读提交隔离级别，每个select都会生成一个新的Read View，意味着事务期间多次读取一个数据，前后可能不一致。
- 可重复读，是在事务启动时生成一个Read View，整个事务其间都是这个Read View。

因此，undo log 的两大作用：
- **实现事务回滚，保障事务的原子性。**
- **实现MVCC的关键因素之一。**

那么undo log 是如何刷盘(持久化到磁盘)的？
undo log和数据的刷盘策略是一样的，都需要通过redo log保证持久化。

buffer pool中有undo页，对undo页的修改都会记录到redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和undo log页都是靠这个机制保证持久化的。

为什么需要buffer pool？

M有SQL的数据是存在磁盘中的，更新记录的时候，要从磁盘读取该记录，然后内存中修改记录。修改完后的记录是直接写回到磁盘，还是缓存起来？

当然是缓存，下次查询语句命中。直接读取缓存中的记录，就不需要从磁盘获取数据了。

为此，InnoDB设计了`缓冲池(Buffer Pool)`，提高数据库的读写性能。

有了buffer pool之后，读取数据，数据在缓冲池中就直接读取缓冲池里的。
修改数据的时候，数据在缓冲池中，就修改缓冲池内的数据，并标记为脏页。为了减少磁盘IO不会把脏页立即写入磁盘，后续由后台线程选择合适时机把脏页写入磁盘。

### Buffer Pool 缓存什么？

InnoDB读取数据按页划分，buffer pool也是一样。

MySQL启动的时候，InnoDB会给buffer pool申请连续的内存空间，按照默认的16KB大小划分一个个的页。

Buffer Pool除了缓存索引页和数据页、还包括undo页、插入缓存、自适应哈希索引、锁信息等。

#### Undo 页是记录什么？
开启事务后，InnoDB更新记录前，首先要记录相应的undo log。如果是更新操作，记录字段的旧值，undo log 会写入Buffer Pool中的undo页面。

#### 查询一条记录，就只需要缓冲一条记录吗？

不是，查询一条记录，InnoDB会把整页的数据加载到缓冲池中，再通过页牡蛎定位具体记录。

## 为什么需要redo log？

上文说道，利用Buffer Pool提高了读写效率，但是它是基于内存的，断电了数据就丢失了。

为了防止这个问题，有记录需要更新的时候，InnoDB先更新内存，标记为脏页，然后把本次对页的修改以redo log的形式记录下来，这个时候更新就算完成了。

后续InnoDB引擎会在适当的时候由后台线程把缓冲池里面的脏页刷新到磁盘里，这个就是WAL(Write-Ahead Logging)技术。

WAL指的是，MySQL的写操作不是立即写在磁盘上，而是先写日志，在合适的时候再写到磁盘上。

### 什么是redo log？

redo log 是物理日志，记录某个数据页做了什么修改，**比如对 XXX 表空间中的 YYY 数据 页 ZZZ 偏移量的地方做了AAA 更新**。

在事务提交时，只需要先将redo log 持久化到磁盘，可以不需要等到将缓存在buffer pool里的脏页数据持久化到磁盘。

假如系统崩溃了，buffer pool里的脏页还没刷盘也没关系，因为redo log 持久化了，MySQL重启之后根据redo log的内容来恢复数据。

### redo log 和undo log的区别？

