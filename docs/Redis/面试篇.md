# Redis常见面试题

开始学习Redis辣！！！

先来张图吧

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%85%AB%E8%82%A1%E6%96%87%E6%8F%90%E7%BA%B2.png)

## 首先，什么是Redis?

Redis是一个开源的内存数据结构存储。用作数据库、缓存、消息代理和流引擎。redis可以通过定期把数据转储到磁盘或者将每个命令附加基于磁盘的日志来持久化数据。

Redis还包括交易、发布/订阅、Lua脚本、生命周期有限的密钥、LRU驱逐密钥、自动故障转移等

Redis是基于内存的数据库，读写速度非常快，常用于缓存、消息队列、分布式锁等场景。

Redis的数据类型有String、Hash、List、Set、Zset、Bitmaps、HyperLogLog、GEO、Stream、并且对数据类型的操作都是原子性的，因为是单线程执行命令，没有并发竞争的问题。

### Redis和Memcached有什么区别？

共同点：
1. 都是基于内存
2. 都有过期策略
3. 性能都很高

区别：
- redis支持的数据类型更丰富，Memcached只支持最简单的key-value类型。
- redis支持数据的持久化，但是memcached没有。
- redis原生支持集群，memcached没有
- redis支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。

### 为什么用Redis作为MySQL的缓存？

主要是因为redis具备高性能和高并发两种特性。

高性能很好理解，因为Redis是基于内存的，读写速度很快。

高并发：单台设备Redis的QPS是MySQL十倍。能轻松破10w，MySQL的单体很难破1w。

### Redis数据结构

Redis数据类型和使用场景分别是什么？

常见的是五种数据类型：String字符串，Hash哈希表，List列表，Set集合，Zset有序集合。

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/key.png)

随着Redis版本的更新，后面又支持了四种数据类型：BitMap、HyperLogLog、GEO、Stream。

不同数据类型的应用场景：
- String：缓存对象、常规计数、分布式锁、共享session信息等。
- List：消息队列
- Hash：缓存对象、购物车等。
- Set：聚合计算（并集、交集、差集），比如点赞、共同关注、抽奖活动等。
- Zset：排序，比如排行榜等。

后续新加的数据类型：
- BitMap：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等。
- HyperLogLog：海量数据基数统计的场景，比如百万级网页UV计数等。(UV:unique visitor)
- GEO：存储地理位置信息的场景
- Stream：消息队列，相比于基于List实现的消息队列，特性为自动生成全局唯一消息ID，支持以消费组形式消费数据。

![image](https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f.png)

#### String实现
String类型底层数据结构主要是SDS，即为简单动态字符串，simple dynamic string。
- 它相比于C样式的String，不仅可以保存文本数据，还可以保存二进制数据。因为SDS使用len属性而不是空字符判断字符串是否结束，并且SDS所有API都会以处理二进制的方式来处理SDS存放在buf[]数组里的数据。
- SDS获取字符串长度时间复杂度是O(1)，因为有len属性。
- SDS的API是安全的，拼接字符串不会造成缓冲区溢出。空间不够会自动扩容

#### List

巴拉巴拉

### Redis线程模型

#### Redis是单线程吗？

Redis单线程指的是`“接收客户端请求->解析请求->数据读写->返回信息给客户端”`这个过程是由主线程完成的，也是为什么常说Redis是单线程的。

但是实际上Redis不是单线程的。Redis在启动的时候，是会开启后台线程BIO的：

Redis2.6，会启动两个后台线程，分别处理关闭文件、AOF刷盘两个任务。

4.0之后有新的lazy free线程，用来异步释放Redis内存。

#### 为什么Redis单线程还是这么快？
Redis的大部分操作都是内存中完成，Redis的瓶颈可能是系统的内存或者网络带宽而非CPU。

单线程模型可以避免多线程竞争，省去了线程切换的开销，也没用死锁问题。

### Redis6.0之前为什么用单线程？

我们都知道单线程程序是无法利用多核CPU的。那么早期Redis的主要工作：网络IO和执行命令为什么还使用单线程呢？

官方给出的说法是：CPU并不是制约Redis性能表现的瓶颈所在。更多是内存大小和网络IO的限制。所以没有必要。

同时单线程的可维护性高。多线程模型虽然在某些情况下表现优异。但是它引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、加锁解锁、死锁等会造成性能损耗的场景。

虽然Redis的主要工作一直是单线程模型，但是在Redis6.0之后，也采用了多个I/O线程在处理网络请求。因为随着硬件性能的提升，Redis的瓶颈有时会出现在网络IO的处理上。

所以为了提高网络IO的并行度，6.0之后用多线程处理网络IO。但是注意，对命令的执行依然还是单线程的。

### Redis持久化

Redis的读写操作都是基于内存的，所以性能才会高。但是当Redis重启之后，内存中的数据就会丢失了。那么为了保证内存中的数据不会丢失，Redis有持久化机制。

Redis一共有三种数据持久化的方式：

- AOF日志：每执行一条写操作命令，把命令以追加的方式写入到一个文件里。
- RDB快照：将某时刻的内存数据，以二进制方式写入磁盘。
- 混合持久化方式：Redis4.0新增的方式，集成了AOF和RDB的优点

#### AOF日志如何实现？

Redis执行完写命令后，把命令以追加的形式写入到文件里，Redis重启时就读取该文件记录的命令，然后逐一执行命令进行数据恢复。

![image](https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7-20230309232240301.png)

为什么先执行命令再写入日志？

1. 避免额外的检查开销：先执行命令，再写日志，这样如果命令是错误的，肯定就执行失败，也就不会写日志了。

2. 不会阻塞当前写操作命令的执行。

当然也会带来风险：
1. 数据可能会丢失。命令执行完，准备写入日志时宕机，数据就丢失了。
2. 可能阻塞其他操作：由于写操作命令执行成功后才记录到AOF，所以不会阻塞当前命令的执行。但是AOF日志的写入也是主线程执行的，会阻塞后续操作。

AOF的写回策略也有三种：有Always、Everysec、no。

always就是每执行一条写命令就写入一次AOF日志。性能最差，但是安全性最高
everysec就是先把写命令写入到AOF文件的内核缓冲区，然后每秒刷盘一次
no就是不由Redis控制写回硬盘的时间，而是交给操作系统。Redis只负责写入到AOF文件的内核缓冲区。

#### AOF日志过大怎么办？

因为每条写指令都会写入到AOF文件，长久以往肯定会导致日志过大。

所以Redis提供了AOF重写机制。当AOF文件大小超过阈值，那么就会读取当前Redis中的所有键值对，然后记录到AOF文件。完毕后，替换掉旧的AOF。

Redis重写AOF的过程是由后台子进程bgrewriteaof完成的。
好处：
- 子进程重写期间，主进程可以继续处理命令请求，不会阻塞
- 子进程有主进程的数据副本。如果使用线程，数据是共享的，多线程之间会有线程安全问题。
那么创建子进程的时候，操作系统会让父子线程先共享数据，而父子进程任意一个修改数据的时候才会实际上给子进程分配单独的数据空间。

但是这里又引入了一个问题。子进程在重写数据的时候，父进程又往AOF写入了数据，那么操作系统发生写时复制，这时就导致父子进程的数据不一致了。怎么办？

为了解决这个数据不一致的问题，Redis设置了AOF重写缓冲区。这个缓冲区在创建bgrewriteaof子进程的时候使用。

在子进程重写AOF文件的期间，Redis执行完一个写命令后，会同时写入AOF缓冲区和AOF重写缓冲区。

子进程重写完毕后，会给主进程发送一条信号。主进程收到信号后会调用一个信号处理函数，主要工作如下：
- 将AOF重写缓冲区中的所有内容追加到AOF文件中，使得新旧两个AOF文件是一致的。
- 新的AOF文件改名，覆盖现有的AOF文件。

