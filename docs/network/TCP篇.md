# 小林coding的TCP篇！

先来一个超级无敌长提纲！
![image](https://cdn.xiaolincoding.com//mysql/other/1310bf5ed78e4c8186481c47719e0793.png)

## TCP基本认识

### TCP头格式有哪些？

![image](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)

- 序列号：在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次数据就累加一次，用来解决网络包乱序的问题。
- 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答之后，可以认为该序号之前的数据都已经被正确接收，是用来解决丢包问题。
- 控制位：
    - ACK：为1时，确认应答字段有效。TCP规定，除了最初建立连接时的SYN包之外，该位置必须设置为1.
    - RST：为1时，说明出现异常，必须强制断开连接，就是reset的意思
    - SYN：为1时，表示希望建立连接，并在序列号字段进行序列号初始值设定，意思应该是，syn为1，那么SEQ数值就是序列号的初始值。
    - FIN：表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的
      TCP 段。

### 为什么需要TCP协议？TCP工作在哪一层？

IP层，也就是网络层，是不可靠的，不保证网络包的交付、按序交付、不保证完整性。

如果要保障数据包的可靠性，就需要由上层TCP协议来负责。

TCP是工作在传输层的可靠的数据传输服务，确保接收端收到的是无损坏、无间隔、非冗余和按序的。

### 什么是TCP？

TCP是面向连接的、可靠的基于字节流的传输协议。

- 面向连接：一定是一对一的，不能像UDP协议一样可以一个主机同时向多个主机发送消息，一对多是无法做到的。
- 可靠的：无论网络链路如何变化，TCP保证一个报文一定能到达接收端。
-
字节流：用户消息通过TCP传输时，数据可能会被操作系统分组成多个TCP包。那么接收方需要知道消息的边界才能读取出有效的用户消息。并且TCP是有序的，当前一个TCP报文没有收到，即使收到了后面的，也不会给应用层处理。重复的TCP报文会自动丢弃。

### 什么是TCP连接？

用于保证可靠性和流量维护的信息的集合称为一个连接，如socket、序列号和窗口大小。

建立一个TCP连接，需要客户端和服务端达成上述消息的共识：

- Socket：由IP地址和端口号组成
- 序列号：用来解决乱序问题
- 窗口大小：流量控制

### 如何唯一确定一个TCP连接？

通过一个四元组：(源地址、源端口、目标地址、目标端口)

其中，源地址和目标地址是不在TCP头部的，在IP中，32位。源端口和目标端口则在TCP头部，64位。

#### 有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？

服务端通常固定在某个本地端口上监听，等待客户端请求。

对IPV4，客户端IP数最多是2^32次方，端口数最多是2^16次方。也就是服务端单机最大TCP连接数，约为2^48.

当然实际上不可能，有以下因素：

- 文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。 Linux
  对可打开的文件描述符的数量分别作了三个方面的限制:
    - 系统级:当前系统可打开的最大数量，通过cat/proc/sys/fs/file-max 查看;
    - 用户级:指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看:
    - 进程级:单个进程可打开的最大数量，通过cat /proc/sys/fs/nr_open 查看
    - 内存限制: 每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会 发生 OOM。

### UDP和TCP的区别？分别的应用场景是？

UDP不提供复杂控制机制，利用IP提供面向无连接的通信服务。

UDP的头部只有8个字节，格式如下：

![image](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png)

包长度保留UDP首部长度跟数据长度之和。校验和是为了提供可靠的UDP首部和数据，防止收到网络传输中受损的UDP包。

### TCP和UDP的区别：

1. 连接

- TCP面向连接，发送数据之前先建立连接。
- UDP不需要连接，即刻传输数据。

2. 服务对象

- TCP是一对一的，UDP则支持一对一、一对多、多对多的交互通信。

3. 可靠性

- TCP是可靠交付的，数据可以无差错，不丢失、不重复、按序到达。
- UDP属于最大努力交付，不保证可靠。但是有基于UDP的可靠传输协议，如QUIC协议，HTTP3就用到了。

4. 拥塞控制、流量控制

- TCP有拥塞控制和流量控制，保证数据传输安全。
- UDP没有

5. 首部开销

- TCP首部长，没用“选项字段”是20个字节、如果用了就更长，而UDP只有8个字节。

6. 传输方式

- TCP是流式传输，没有边界，但保证顺序和可靠
- UDP是以包为单位发送，有边界，但可能乱序和丢包

7. 分片不同

- TCP数据大小如果超过MSS，Max Segment Size，则会在传输层分片，目标收到后也在传输层组装分片，如果中途丢失了，只需要传输这个丢失的分片。
- UDP的数据如果大于MTU大小，则会在IP层分片，目标主机收到后，在IP层组装完数据，接着再传给传输层。MTU是max transmission unit。是数据链路层的概念，一般以太网的MTU是1500字节，包括IP头部。

#### 为什么分片层次不一样？
这里是我结合deepseek得到的结果。

TCP协议在握手的时候，也就是SYN为1的时候，会有选项字段，里面规定了MSS(一般是MTU-20-20，20是TCP首部长度，和IP首部长度。MTU一般是1500字节)。因此TCP自己会先主动分片，因为如果在IP层分片丢失，会导致整个数据包重传。

而UDP则摆烂，啥也不管，丢给下层网络层IP做处理，让IP层检查到数据超过MTU，被迫在IP层分片。

### TCP和UDP应用场景

- 由于TCP面向连接，能保证数据的可靠交付，经常用于FTP文件传输，HTTP/HTTPS。
- 由于UDP面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，常用于：
    - 包总量较少的通信，如DNS、SNMP等；
    - 视频、音频等多媒体通信
    - 广播通信

### 为什么UDP头部没首部长度，而TCP有？
原因是TCP首部有可变长的选项字段，而UDP长度不变，无需多一个字段去记录UDP首部长度。

### 为什么UDP头部有包长度，TCP没有？

TCP如何计算负载数据长度？ IP总长-IP首部长-TCP首部长。

为什么UDP不这么算？小林coding认为两种可能：

第一种说法:因为为了网络设备硬件设计和处理方便，首部长度需要是 4字节的整数倍。如果去掉
UDP 的「包长度」字段，那 UDP 首部长度就不是 4 字节的整数倍了，所以我觉得这可能是为了补全
UDP 首部长度是 4字节的整数倍，才补充了「包长度」字段。

第二种说法:如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供
自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。

